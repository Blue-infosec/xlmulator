"""@package ms_stack_transformer

Lark AST transformer to generate XLM_Objects from an AST generated by ms_xlm.bnf.
"""

from __future__ import print_function
import string

from lark import Transformer

from XLM.stack_item import *
from XLM.XLM_Object import *

####################################################################
def _load_stack_args(args, stack):
    """
    Load the arguments of a function call onto the given stack.

    @param args (list) stack_items for the function arguments.
    @param stack (list) The stack on which to push the call arguments.

    @return (list) Return the updated stack.
    """

    # Process each argument.
    while (len(args) > 0):
    
        # Pull an arg.
        item = args[0]
        args = args[1:]

        # Simple case is a literal.
        if (not isinstance(item, list)):
            stack.append(item)
            continue

        # Single item as 2nd argument to a ninfix operator.
        if (len(item) == 1):
            stack.append(item[0])
            continue
            
        # 2nd item (infix) in the list is the operator.
        op = item[1]
        first_arg = item[0]
        second_arg = item[2:]
        if (len(second_arg) == 1):
            second_arg = second_arg[0]
        
        # Nested expression involving another operator with args.
        stack = _load_stack([op, [first_arg, second_arg]], stack)

    # Return the updated stack.
    return stack

####################################################################
def _load_stack(items, stack):
    """
    Work through a function call and its arguments and load them as stack_item
    objects onto a stack.

    @param items (list) The items making up the CALL.
    @param stack (list) The stack onto which to push the items.

    @return (list) A stack of stack_item objects representing the CALL.
    """

    # ['ALERT', ["The workbook cannot be opened or repaired by Microsoft Excel because it's corrupt.", 2, [1, +, [3, *, 2], +, [[2, -, 5], *, 4]], ["ff", &, "dd", &, "ss"]]]

    # The function args are a list in the 2nd element.
    func_args = items[1]

    # The name of the function being called is the 1st argument.
    func_name = items[0]
    num_args = len(func_args)
    if (not isinstance(func_name, stack_item)):
        top_func = stack_func_var(func_name, num_args)
    else:
        top_func = func_name

    # Push the arguments on the stack.
    stack = _load_stack_args(func_args, stack)

    # Call goes on the top of the stack.
    stack.append(top_func)

    # Done.
    return stack
    
####################################################################
class MsStackTransformer(Transformer):
    """
    Lark AST transformer to generate XLM_Objects from an AST generated by ms_xlm.bnf.
    """

    ##########################################################
    ## Non-terminal Transformers
    ##########################################################

    def start(self, items):
        return items[0]

    def function_call(self, items):

        # Make the function call stack.
        stack = []
        stack = _load_stack(items, stack)

        # Nested calls are represented as XLM_Objects by the transformer. Pull out
        # the stacks of these XLM objects and add them to the single stack for the
        # expression.
        new_stack = []
        for s in stack:
            if (isinstance(s, XLM_Object)):
                for s1 in s.stack:
                    new_stack.append(s1)
            else:
                new_stack.append(s)
        stack = new_stack
        
        # Create the XLM object for the call. We don't know the column and row at this point.
        xlm_object = XLM_Object(-1, -1, stack)
        
        return xlm_object
    
    def method_call(self, items):
        new_items = [items[0] + "." + items[1], items[2]]

        # Make the function call stack.
        stack = []
        stack = _load_stack(new_items, stack)
        
        # Create the XLM object for the call. We don't know the column and row at this point.
        xlm_object = XLM_Object(-1, -1, stack)
        return xlm_object
    
    def arglist(self, items):
        return items
    
    def argument(self, items):
        if (len(items) > 0):
            return items[0]
        return stack_attr()
    
    def cell(self, items):
        return items
    
    def a1_notation_cell(self, items):
        return items
    
    def r1c1_notation_cell(self, items):
        return items

    def expression(self, items):
        return items[0]
    
    def concat_expression(self, items):
        return items
    
    def additive_expression(self, items):
        return items
    
    def multiplicative_expression(self, items):
        return items
    
    def final(self, items):
        return items
    
    def atom(self, items):
        return items

    ##########################################################
    ## Terminal Transformers
    ##########################################################
    
    def ADDITIVEOP(self, items):
        op = items[0]
        if (op == "+"):
            return stack_add()
        if (op == "-"):
            return stack_sub()
        raise ValueError("Unkown operator '" + str(op) + "'.")

    def MULTIOP(self, items):
        op = items[0]
        if (op == "*"):
            return stack_mul()
        if (op == "/"):
            return stack_div()
        raise ValueError("Unkown operator '" + str(op) + "'.")
    
    def CMPOP(self, items):
        op = items[0]
        if (op == "<"):
            return stack_less_than()
        if (op == ">"):
            return stack_greater_than()
        if (op == "="):
            return stack_equal()
        if (op == "<>"):
            return stack_not_equal()
        raise ValueError("Unkown operator '" + str(op) + "'.")
    
    def CONCATOP(self, items):
        return stack_concat()
    
    def STRING(self, items):
        return stack_str(items[1:-1])
    
    def BOOLEAN(self, items):
        return stack_bool(items)
    
    def ROW(self, items):
        return items[0]
    
    def COL(self, items):
        return items[0]
        
    def REF(self, items):
        return items
    
    def NAME(self, items):
        return str(items)
    
    def SIGNED_INT(self, items):
        return int(items)
    
    def INT(self, items):
        return int(items)
    
    def DECIMAL(self, items):
        return stack_float(items)
    
    def SIGNED_DECIMAL(self, items):
        return float(items)
    
    def NUMBER(self, items):
        return stack_int(items)
    
