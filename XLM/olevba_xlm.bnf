// CFG for olevba XLM macro code generated by Didier Stevens plugin_biff module.
// CFG is written for the Python lark parser.

// olevba XLM output has multiple lines.
lines: ("\n"? xlm_line "\n")+
xlm_line: "' " NUMBER " "~3..6 NUMBER " " LINE_TYPE " : " data

// The main types of XLM lines are basic info about sheets, cell values, cells with
// XLM formulas, and string value calls.
data: sheet_info | cell_value | cell_formula | string_value | data_conn

// Just pull off the info string from sheet info lines.
sheet_info: "Sheet Information - " STRING
// Just pull off the info string from cell value lines.
cell_value: "Cell Value, " STRING
// Just pull off the info string from string value lines.
string_value: "String Value of a " STRING
data_conn: "Data Connection"

// XLM formula lines are what we are interested. XLM operates as a stack machine,
// so what we get from the olevba output is a list of items that are pushed
// onto the XLM stack when the cell is initially executed.
//
// When parsing this we are parsing out each XLM stack item as a seperate nonterminal.
cell_formula: "Cell Formula - " cell " len=" NUMBER (" " stack_item)+ unparsed? " "?

// Parse out the row and column of a cell identifier.
cell: "R" NUMBER "C" NUMBER
cell_area: ("R" NUMBER? "~" NUMBER? "C" NUMBER? "~" NUMBER?)
           | ("R" NUMBER "C" NUMBER? "~" NUMBER?)
           | ("R" NUMBER? "~" NUMBER? "C" NUMBER)
           | cell_area_col
           | cell_area_row
cell_area_col: ("C" NUMBER)
cell_area_row: ("R" NUMBER)

// These are all the items that can be pushed onto the XLM stack.
stack_item: stack_int | stack_funcv | stack_concat
            | stack_cell_ref | stack_str
            | stack_bool | stack_attr | stack_add
            | stack_sub | stack_exp | stack_name
            | stack_num | stack_missing_arg | stack_func
            | stack_func_var | stack_namev | stack_area
            | stack_less_than | stack_namex | stack_not_equal
            | stack_mul | stack_paren | unknown_token
            | stack_array | stack_equal | stack_greater_than
            | stack_mem_func | stack_power | stack_ref_error
            | stack_mem_no_mem | stack_area_error | stack_div
            | stack_uminus | stack_greater_equal | stack_area_3d
            | stack_end_sheet | stack_mem_error | stack_percent
            | stack_mem_area | stack_range | stack_uplus

unparsed: " "* "*INCOMPLETE FORMULA PARSING* Remaining, unparsed expression: " (DOUBLE_QUOTE_STRING|SINGLE_QUOTE_STRING)
unknown_token: "*UNKNOWN TOKEN* " HEX_NUMBER
stack_int: "ptgInt " NUMBER
stack_funcv: "ptgFuncV " NAME " (" HEX_NUMBER ")"
stack_concat: "ptgConcat"
stack_cell_ref: "ptgRef" "3d"? "V"? " " (cell|cell_area)
stack_str: "ptgStr " (DOUBLE_QUOTE_STRING|SINGLE_QUOTE_STRING)
stack_bool: "ptgBool " BOOLEAN
stack_attr: "ptgAttr"
stack_add: "ptgAdd"
stack_sub: "ptgSub"
stack_exp: "ptgExp " cell
stack_name: "ptgName " HEX_NUMBER
stack_num: "ptgNum " NAME
stack_missing_arg: "ptgMissArg"
stack_func: "ptgFunc " (NAME|UNKNOWN_FUNC)
stack_func_var: "ptgFuncVar" "A"? "V"? " args " NUMBER " func " (USER_DEFINED|NAME) " (" HEX_NUMBER ")"
stack_namev: "ptgNameV"
stack_area: "ptgArea " cell_area
stack_less_than: "ptgLT"
stack_namex: "ptgNameX" " "+ NAME " " NUMBER
stack_not_equal: "ptgNE"
stack_mul: "ptgMul"
stack_paren: "ptgParen"
stack_array: "ptgArray"
stack_equal: "ptgEQ"
stack_greater_than: "ptgGT"
stack_greater_equal: "ptgGE"
stack_mem_func: "ptgMemFunc"
stack_power: "ptgPower"
stack_ref_error: "ptgRefErr" "3d"? "A"? "V"?
stack_mem_no_mem: "ptgMemNoMem" "A"? "V"?
stack_area_error: "ptgAreaErrV" "A"? "V"?
stack_div: "ptgDiv"
stack_uminus: "ptgUminus"
stack_uplus: "ptgUplus"
stack_area_3d: "ptgArea3d" "A"? "V"?
stack_end_sheet: "ptgEndSheet"
stack_mem_error: "ptgMemErr"
stack_percent: "ptgPercent"
stack_mem_area: "ptgMemArea" (" " REFERENCE_EXP)?
stack_range: "ptgRange"

// Literal definitions.
NUMBER: ("0".."9")+
HEX_NUMBER: "0x" ("0".."9"|"a".."f")+
LINE_TYPE: "BOUNDSHEET" | "LABEL" | "FORMULA" | "STRING" | "DCONN"
STRING: /[^\n]+/
DOUBLE_QUOTE_STRING: /"[^"]*"/
SINGLE_QUOTE_STRING: /'[^']*'/
NAME: /[\w\.]+/
USER_DEFINED.2: "User Defined Function"
UNKNOWN_FUNC.2: "*UNKNOWN FUNCTION*"
BOOLEAN: "TRUE" | "FALSE"
REFERENCE_EXP.2: "REFERENCE-EXPRESSION"
